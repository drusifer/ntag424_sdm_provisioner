from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
import os

class Ntag424AuthSession:
    """Handles EV2 authentication crypto and session key derivation."""
    
    def __init__(self, key: bytes):
        """
        Args:
            key: 16-byte AES-128 key (factory default = 16 zeros)
        """
        if len(key) != 16:
            raise ValueError("Key must be 16 bytes")
        self.key = key
        self.session_enc_key = None
        self.session_mac_key = None
        self.ti = None  # Transaction Identifier
        self.cmd_counter = 0
    
    def authenticate_phase1(self, card, key_no: int = 0):
        """Execute Phase 1 and return encrypted RndB."""
        response = AuthenticateEV2First(key_no).execute(card)
        return response.challenge  # 16 bytes encrypted RndB
    
    def authenticate_phase2(self, card, encrypted_rndb: bytes) -> bytes:
        """
        Decrypt RndB, generate RndA, create response, derive session keys.
        Returns: decrypted TI from card response
        """
        # 1. Decrypt RndB from card
        cipher = AES.new(self.key, AES.MODE_CBC, iv=b'\x00' * 16)
        rndb = cipher.decrypt(encrypted_rndb)
        
        # 2. Rotate RndB (shift left 1 byte)
        rndb_rotated = rndb[1:] + rndb[0:1]
        
        # 3. Generate random RndA
        rnda = get_random_bytes(16)
        
        # 4. Encrypt RndA + RndB_rotated
        cipher = AES.new(self.key, AES.MODE_CBC, iv=b'\x00' * 16)
        response_data = cipher.encrypt(rnda + rndb_rotated)
        
        # 5. Send to card
        auth_response = AuthenticateEV2Second(response_data).execute(card)
        
        # 6. Card responds with encrypted(Ti || RndA_rotated || PDcap || PCDcap)
        # For now, we'll derive session keys from RndA and RndB
        self._derive_session_keys(rnda, rndb)
        
        return auth_response
    
    def _derive_session_keys(self, rnda: bytes, rndb: bytes):
        """
        Derive session encryption and MAC keys.
        NTAG424 DNA uses specific SV derivation from spec.
        """
        # SV1 = 0xA5 5A 00 01 00 80 || RndA[0:2]
        sv1 = b'\xA5\x5A\x00\x01\x00\x80' + rnda[0:2]
        
        # SV2 = 0x5A A5 00 01 00 80 || RndA[0:2]  
        sv2 = b'\x5A\xA5\x00\x01\x00\x80' + rnda[0:2]
        
        # Derive using CMAC
        from Crypto.Hash import CMAC
        
        # Session ENC key
        cmac_enc = CMAC.new(self.key, ciphermod=AES)
        cmac_enc.update(sv1 + b'\x00' * 8)
        self.session_enc_key = cmac_enc.digest()
        
        # Session MAC key
        cmac_mac = CMAC.new(self.key, ciphermod=AES)
        cmac_mac.update(sv2 + b'\x00' * 8)
        self.session_mac_key = cmac_mac.digest()
        
        log.info(f"Session keys derived: ENC={self.session_enc_key.hex()}, MAC={self.session_mac_key.hex()}")