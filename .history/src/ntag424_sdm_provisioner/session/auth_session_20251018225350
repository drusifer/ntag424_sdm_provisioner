from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
import os

# file: ntag424_sdm_provisioner/utils/sdm_helpers.py

from typing import Dict
from ntag424_sdm_provisioner.commands.base import SDMUrlTemplate, SDMConfiguration, FileOption

def calculate_sdm_offsets(template: SDMUrlTemplate) -> Dict[str, int]:
    """
    Calculate byte offsets for SDM mirrors in NDEF message.
    
    Args:
        template: URL template with placeholders
    
    Returns:
        Dictionary with offset keys for SDMConfiguration
    """
    # Build full URL
    params = [f"uid={template.uid_placeholder}"]
    if template.cmac_placeholder:
        params.append(f"cmac={template.cmac_placeholder}")
    if template.enc_placeholder:
        params.append(f"enc={template.enc_placeholder}")
    if template.read_ctr_placeholder:
        params.append(f"ctr={template.read_ctr_placeholder}")
    
    url = f"{template.base_url}?{'&'.join(params)}"
    
    # NDEF Type 4 Tag overhead
    # [T=03][L][Record Header (5 bytes)][URI Prefix=04][URL...]
    # Typical overhead = 7 bytes
    ndef_overhead = 7
    
    offsets = {}
    
    # Find UID offset
    uid_start = url.find(template.uid_placeholder)
    if uid_start != -1:
        offsets['picc_data_offset'] = ndef_overhead + uid_start
        offsets['mac_input_offset'] = ndef_overhead + uid_start
    
    # Find CMAC offset
    cmac_start = url.find(template.cmac_placeholder)
    if cmac_start != -1:
        offsets['mac_offset'] = ndef_overhead + cmac_start
    
    # Find encrypted data offset
    if template.enc_placeholder:
        enc_start = url.find(template.enc_placeholder)
        if enc_start != -1:
            offsets['enc_data_offset'] = ndef_overhead + enc_start
            offsets['enc_data_length'] = len(template.enc_placeholder) // 2
    
    # Find read counter offset
    if template.read_ctr_placeholder:
        ctr_start = url.find(template.read_ctr_placeholder)
        if ctr_start != -1:
            offsets['read_ctr_offset'] = ndef_overhead + ctr_start
    
    return offsets


def build_sdm_settings_payload(config: SDMConfiguration) -> bytes:
    """
    Build the file settings data payload for ChangeFileSettings command.
    
    Args:
        config: SDM configuration
    
    Returns:
        Byte array ready to send to card
    """
    # Start with comm mode and access rights
    data = bytearray([config.comm_mode])
    data.extend(config.access_rights)
    
    if not config.enable_sdm:
        return bytes(data)
    
    # SDM options byte
    sdm_opts = config.sdm_options or (FileOption.SDM_ENABLED | FileOption.UID_MIRROR)
    data.append(sdm_opts)
    
    # Helper to add 3-byte little-endian offset
    def add_offset(value: int):
        data.extend([
            value & 0xFF,
            (value >> 8) & 0xFF,
            (value >> 16) & 0xFF
        ])
    
    # Add required offsets
    add_offset(config.picc_data_offset)
    add_offset(config.mac_input_offset)
    
    # Optional encrypted data mirror
    if config.enc_data_offset is not None:
        add_offset(config.enc_data_offset)
        add_offset(config.enc_data_length)
    
    # MAC offset
    add_offset(config.mac_offset)
    
    # Optional read counter
    if config.read_ctr_offset is not None:
        add_offset(config.read_ctr_offset)
    
    return bytes(data)


def build_ndef_uri_record(url: str) -> bytes:
    """
    Build NDEF Type 4 Tag message with URI record.
    
    Args:
        url: Complete URL (with or without placeholders)
    
    Returns:
        NDEF message bytes ready to write to file
    """
    # URI identifier codes (0x04 = "https://")
    uri_prefix = 0x04
    
    # Remove "https://" from URL since we use prefix code
    if url.startswith("https://"):
        url_content = url[8:]
    elif url.startswith("http://"):
        uri_prefix = 0x03
        url_content = url[7:]
    else:
        uri_prefix = 0x00  # No prefix
        url_content = url
    
    url_bytes = url_content.encode('ascii')
    
    # NDEF Record: [Header][Type Length][Payload Length][Type][Payload]
    ndef_record = bytes([
        0xD1,  # MB=1, ME=1, CF=0, SR=1, IL=0, TNF=0x01 (Well-known)
        0x01,  # Type Length = 1
        len(url_bytes) + 1,  # Payload length (prefix + URL)
        0x55,  # Type = 'U' (URI)
        uri_prefix  # URI prefix code
    ]) + url_bytes
    
    # Wrap in TLV: [T=03][L][NDEF Record][T=FE]
    ndef_message = bytes([
        0x03,  # NDEF Message TLV
        len(ndef_record)
    ]) + ndef_record + bytes([0xFE])  # Terminator TLV
    
    return ndef_message

class Ntag424AuthSession:
    """Handles EV2 authentication crypto and session key derivation."""
    
    def __init__(self, key: bytes):
        """
        Args:
            key: 16-byte AES-128 key (factory default = 16 zeros)
        """
        if len(key) != 16:
            raise ValueError("Key must be 16 bytes")
        self.key = key
        self.session_enc_key = None
        self.session_mac_key = None
        self.ti = None  # Transaction Identifier
        self.cmd_counter = 0
    
    def authenticate_phase1(self, card, key_no: int = 0):
        """Execute Phase 1 and return encrypted RndB."""
        response = AuthenticateEV2First(key_no).execute(card)
        return response.challenge  # 16 bytes encrypted RndB
    
    def authenticate_phase2(self, card, encrypted_rndb: bytes) -> bytes:
        """
        Decrypt RndB, generate RndA, create response, derive session keys.
        Returns: decrypted TI from card response
        """
        # 1. Decrypt RndB from card
        cipher = AES.new(self.key, AES.MODE_CBC, iv=b'\x00' * 16)
        rndb = cipher.decrypt(encrypted_rndb)
        
        # 2. Rotate RndB (shift left 1 byte)
        rndb_rotated = rndb[1:] + rndb[0:1]
        
        # 3. Generate random RndA
        rnda = get_random_bytes(16)
        
        # 4. Encrypt RndA + RndB_rotated
        cipher = AES.new(self.key, AES.MODE_CBC, iv=b'\x00' * 16)
        response_data = cipher.encrypt(rnda + rndb_rotated)
        
        # 5. Send to card
        auth_response = AuthenticateEV2Second(response_data).execute(card)
        
        # 6. Card responds with encrypted(Ti || RndA_rotated || PDcap || PCDcap)
        # For now, we'll derive session keys from RndA and RndB
        self._derive_session_keys(rnda, rndb)
        
        return auth_response
    
    def _derive_session_keys(self, rnda: bytes, rndb: bytes):
        """
        Derive session encryption and MAC keys.
        NTAG424 DNA uses specific SV derivation from spec.
        """
        # SV1 = 0xA5 5A 00 01 00 80 || RndA[0:2]
        sv1 = b'\xA5\x5A\x00\x01\x00\x80' + rnda[0:2]
        
        # SV2 = 0x5A A5 00 01 00 80 || RndA[0:2]  
        sv2 = b'\x5A\xA5\x00\x01\x00\x80' + rnda[0:2]
        
        # Derive using CMAC
        from Crypto.Hash import CMAC
        
        # Session ENC key
        cmac_enc = CMAC.new(self.key, ciphermod=AES)
        cmac_enc.update(sv1 + b'\x00' * 8)
        self.session_enc_key = cmac_enc.digest()
        
        # Session MAC key
        cmac_mac = CMAC.new(self.key, ciphermod=AES)
        cmac_mac.update(sv2 + b'\x00' * 8)
        self.session_mac_key = cmac_mac.digest()
        
        log.info(f"Session keys derived: ENC={self.session_enc_key.hex()}, MAC={self.session_mac_key.hex()}")