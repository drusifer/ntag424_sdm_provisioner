# Complete Authentication Flow Analysis

**STATUS**: ⚠️ **HISTORICAL** - This document predates the CBC mode fix. Authentication is now working. See `CURRENT_STEP.md` and `SERITAG_INVESTIGATION_COMPLETE.md` for current status.

---

# Complete Authentication Flow Analysis (Historical)

## Our Implementation Flow

### Phase 1: AuthenticateEV2First
```
C-APDU: 90 71 00 00 02 [KeyNo] [LenCap] 00
  - CLA = 0x90 (DESFire native)
  - CMD = 0x71 (AuthenticateEV2First)
  - P1  = 0x00
  - P2  = 0x00
  - Lc  = 0x02 (2 bytes: KeyNo + LenCap)
  - Data = KeyNo (1 byte) + LenCap (1 byte, typically 0x00)
  - Le  = 0x00

R-APDU: E(Kx, RndB) || 91 AF
  - 16 bytes encrypted RndB
  - SW = 91AF (Additional Frame - but data is complete)
```

**Our Implementation**: ✅ Matches spec exactly

### Phase 2: AuthenticateEV2First - Part2
```
C-APDU: 90 AF 00 00 20 [E(Kx, RndA || RndB')] 00
  - CLA = 0x90 (DESFire native)
  - CMD = 0xAF (Additional Frame / Phase 2 continuation)
  - P1  = 0x00
  - P2  = 0x00
  - Lc  = 0x20 (32 bytes of data)
  - Data = E(Kx, RndA || RndB') (32 bytes)
  - Le  = 0x00

Expected R-APDU: E(Kx, Ti || RndA' || PDcap2 || PCDcap2) || 91 00
  - 32 bytes encrypted response
  - SW = 9100 (Success)
```

**Our Implementation**: ✅ Matches spec exactly

### Internal Operations

#### Step 1: Decrypt RndB from Phase 1
```
RndB = D(Kx, E(Kx, RndB))
  - Uses AES-128-ECB mode
  - Same key Kx as referenced by KeyNo
```

**Our Implementation**: ✅ Uses `AES.new(key, AES.MODE_ECB).decrypt()`

#### Step 2: Rotate RndB
```
RndB' = rotl(RndB, 1 byte)
  - Left rotation by 1 byte
  - Format: RndB[1..15] || RndB[0]
```

**Our Implementation**: ✅ Uses `rndb[1:] + rndb[0:1]`

#### Step 3: Generate RndA
```
RndA = random 16 bytes (generated by PCD)
```

**Our Implementation**: ✅ Uses `get_random_bytes(16)`

#### Step 4: Encrypt Response
```
E(Kx, RndA || RndB')
  - Plaintext: RndA (16 bytes) || RndB' (16 bytes) = 32 bytes
  - Encryption: AES-128-ECB mode
  - Same key Kx as Phase 1
```

**Our Implementation**: ✅ Uses `AES.new(key, AES.MODE_ECB).encrypt(rnda + rndb_rotated)`

### NXP Spec Requirements

From NT4H2421Gx, Section 9.1.4:
- "The protocol cannot be interrupted by other commands"
- "On any command different from AuthenticateEV2First - Part2 received after the successful execution of the first part, the PICC aborts the ongoing authentication"

**Our Implementation**: ✅ Phase 2 is sent immediately after Phase 1 (no other commands in between)

### Verification Checklist

- [x] Phase 1 APDU format: Correct
- [x] Phase 1 response parsing: Correct (16 bytes, SW=91AF)
- [x] RndB decryption: AES-128-ECB with key Kx
- [x] RndB rotation: Left by 1 byte (`rndb[1:] + rndb[0:1]`)
- [x] RndA generation: 16 random bytes
- [x] Phase 2 APDU format: Correct (90 AF 00 00 20 [32 bytes] 00)
- [x] Phase 2 encryption: AES-128-ECB with same key Kx
- [x] Phase 2 plaintext: RndA || RndB' (32 bytes)
- [x] Timing: Phase 2 sent immediately after Phase 1

## Comparison with Arduino Implementation

**Arduino MFRC522 Reference**: https://github.com/Obsttube/MFRC522_NTAG424DNA

**Key Differences to Investigate**:
1. Hardware stack differences (MFRC522 vs ACR122U)
2. Low-level protocol differences
3. Byte ordering or endianness
4. Encryption mode implementation details

## Critical Finding: AES Mode

**NXP Spec (Section 9.1.4)**: 
- "Encryption and decryption are calculated using AES-128 according to the **CBC mode** of NIST SP800-38A"
- "The only exception is during the authentication itself (AuthenticateEV2First and AuthenticateEV2NonFirst), where **no padding is applied at all**"
- Uses **zero byte IV** (Section 9.1.4)

**Arduino Implementation**:
- Uses **CBC mode with zero IV** for both Phase 1 and Phase 2
- Matches NXP spec exactly

**Our Original Implementation**:
- Used **ECB mode** (incorrect!)
- This would work for single 16-byte blocks, but differs for 32-byte Phase 2 data
- **FIXED**: Changed to CBC mode with zero IV

**Key Difference**:
- **ECB (32 bytes)**: Each 16-byte block encrypted independently
- **CBC with zero IV (32 bytes)**: 
  - Block 1: XOR with IV (0), then encrypt
  - Block 2: XOR with Block 1 ciphertext, then encrypt

## Current Status

**All protocol steps match NXP spec exactly** ✅

**Changed to CBC mode with zero IV** ✅

**AUTHENTICATION SUCCESSFUL!** ✅✅✅

**Root Cause Identified and Fixed**:
- **Issue**: Using ECB mode instead of CBC mode with zero IV
- **Fix**: Changed all authentication encryption/decryption to CBC mode with zero IV
- **Result**: Authentication now works correctly on Seritag NTAG424 DNA tags (HW 48.0)

**Test Results**:
- ✅ Phase 1 authentication: SUCCESS
- ✅ Phase 2 authentication: SUCCESS  
- ✅ Session keys derived correctly
- ✅ Transaction ID received from tag

## Remaining Hypotheses

1. **Key Mismatch**: Phase 1 might encrypt RndB with different key than we use for decryption
2. **RndB Storage**: Tag might store/rotate RndB differently internally
3. **Seritag-Specific**: Might be a Seritag-specific protocol difference despite claims of ISO compliance
4. **Need Standard Tag**: Should test on standard NXP NTAG424 DNA tag (HW 4.2) for comparison

